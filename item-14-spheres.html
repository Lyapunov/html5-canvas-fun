<!DOCTYPE HTML>
<html>
   <head>
      <style>
         body {
            margin : 0px;
            padding: 0px;
         }
      </style>
   </head>
   <body>
   	<canvas id="canvas" width="500" height="500">
      Your browser doesn't support html5 canvas.
      </canvas>
      <script>
         var mainItem     = document.getElementById('canvas');
         var context      = mainItem.getContext('2d');

         var screenWidth  = mainItem.width  = window.innerWidth  - 20;
         var screenHeight = mainItem.height = window.innerHeight - 20;
         var screenScale  = Math.min( screenWidth, screenHeight ) / 2;
         var screenWidthInScale  = screenWidth  / screenScale;
         var screenHeightInScale = screenHeight / screenScale;

         var fps = 25;
         var ANIMATION;

         var sphereResolution = 20;
         var sphereRad = 0.75;
         var eyeDist = 1.5;
         var baseY = 0;
         var eyeY = -3;

         var backgroundResolution = 0.05;

         function calculateSphericDeviationFromPoint( xz, alpha, beta, radius ) {
            var dx = Math.sin( alpha ) * Math.cos( beta ) * radius;
            var dy = Math.cos( alpha ) * Math.cos( beta ) * radius;
            var dz = Math.sin( beta )  * radius;

            var px = xz[0] * eyeDist / (baseY - eyeY);
            var py = xz[1] * eyeDist / (baseY - eyeY);

            var ptx = ( xz[0] + dx ) * eyeDist / ( baseY - eyeY - dy );
            var pty = ( xz[1] + dz ) * eyeDist / ( baseY - eyeY - dy );

            return [ptx - px + xz[0], pty - py + xz[1]];
         }

         function convertCoordsToPoint( cxy ) {
            return [ screenWidth  / 2 + screenScale * cxy[0],
                     screenHeight / 2 + screenScale * cxy[1] ];
         }

         function drawPoly( color, vertices ) {
            context.fillStyle = color;
            var isFirst = 1;
            context.beginPath();
            vertices.forEach( function( pxy ) {
               if ( isFirst ) {
                  isFirst = 0;
                  context.moveTo( pxy[0], pxy[1] );
               } else {
                  context.lineTo( pxy[0], pxy[1] );
               }
            });
            context.closePath();
            context.fill();
         };

         function drawSphere( cxy  ) {
            var angStep = Math.PI / sphereResolution;
            
            for ( var i = -Math.floor( sphereResolution / 2 ) - 1; i < sphereResolution -Math.floor( sphereResolution / 2 ); ++i ) {
               for ( var j = -Math.floor( sphereResolution / 2 ) - 1; j < sphereResolution -Math.floor( sphereResolution / 2 ); ++j ) {
                  var vertices = [ convertCoordsToPoint( calculateSphericDeviationFromPoint( cxy, (i  ) * angStep, (j  ) * angStep, sphereRad ) ),
                                   convertCoordsToPoint( calculateSphericDeviationFromPoint( cxy, (i+1) * angStep, (j  ) * angStep, sphereRad ) ),
                                   convertCoordsToPoint( calculateSphericDeviationFromPoint( cxy, (i+1) * angStep, (j+1) * angStep, sphereRad ) ),
                                   convertCoordsToPoint( calculateSphericDeviationFromPoint( cxy, (i  ) * angStep, (j+1) * angStep, sphereRad ) ) ];

                  var col = ( ( i + j + 10000 ) % 2 ) ? "yellow" : "red";
                  drawPoly( col, vertices );
               }
            }
         }

         function drawBackground() {
            context.fillStyle = "black";
            context.fillRect(0,0,screenWidth,screenHeight);

            var limitX = Math.floor( screenWidthInScale  / backgroundResolution ) + 1;
            var limitY = Math.floor( screenHeightInScale / backgroundResolution ) + 1;
            for ( var i = 0; i < limitX; ++i ) {
               for ( var j = 0; j < limitY; ++j ) {
                  var sxy  = convertCoordsToPoint(  [ ( i * backgroundResolution ) - ( Math.floor ( limitX / 2 ) * backgroundResolution ),
                                                      ( j * backgroundResolution ) - ( Math.floor ( limitY / 2 ) * backgroundResolution ) ] );
                  var sxy2 = convertCoordsToPoint(  [ ( ( i + 1 ) * backgroundResolution ) - ( Math.floor ( limitX / 2 ) * backgroundResolution ),
                                                      ( ( j + 1 ) * backgroundResolution ) - ( Math.floor ( limitY / 2 ) * backgroundResolution ) ] );

                  // selecting colorset
                  var ri = ( ( i + 1 ) * backgroundResolution ) > ( Math.floor ( limitX / 2 ) * backgroundResolution );
                  var up = ( ( j + 1 ) * backgroundResolution ) > ( Math.floor ( limitY / 2 ) * backgroundResolution );
                  var colset = [ ["yellow", "red"],
                                 ["green" , "blue"],
                                 ["white" , "black"],
                                 ["magenta" , "cyan"] ];
                  var col = colset[ ri * 2 + up ];

                  context.fillStyle = col[ ( i + j + 10000 ) % 2 ];
                  context.fillRect(sxy[0], sxy[1], sxy2[0] - sxy[0] + 1, sxy2[1] - sxy[1] + 1);
               }
            }
         }

         // common functions 
         function drawScene() {
            setTimeout( function() {
               drawBackground();
               drawSphere( [0, 0] );
               ANIMATION = requestAnimationFrame(drawScene);
            }, 1000 / fps );
         }

         function initCanvas() {
            screenWidth  = mainItem.width  = window.innerWidth  - 20;
            screenHeight = mainItem.height = window.innerHeight - 20;
            screenScale  = Math.min( screenWidth, screenHeight ) / 2;

            // starting the engine only if it is not running
            if ( !ANIMATION ) {
               drawScene();
            }
         }

         //init
         (function() {
            initCanvas();
            addEventListener('resize', initCanvas, false);
         })();
      </script>
   </body>
</html>
